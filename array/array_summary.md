# 数组题目总结

- continue语句也是挺耗时间的

- 遍历的 two pointers 从两边向中间或者从中间向两边

- 注意循环的终止条件以及初始化值的处理

## 排序

### 一个待处理数组，一个参考数组，统计前者的元素数量，然后根据特征提取元素

- 1122

- 特征数组处理，统计元素数量后合并产生结果数组

- 这里是先统计数量，再根据另一个数组的顺序来将第一个数组的元素保存

- 即先统计所有出现的元素的数量，之后，分两次将元素拿出来

### 元素数值特征排序

- 905 奇数，偶数排序

### 原数组是升序，需要对每个元素进行计算乘方再排序

#### 977

- 已排序数组的平方排序数组

1. 可以使用上面的归并方法然后再把结果数组翻转一下，类似 88

2. 因为有正负数一起排序，所以从中间找两个指针来往两边遍历处理，其中第一个指针可以是第一个大于等于0的元素，
第二个指针是第一个指针的上一个元素

### 乱序数组找最小差值

- 1200 先排序，之后按顺序，一边统计最小差值，同时将等于该值的序对保存

### 判断数组是否升序或者降序 可以使用两个值记录

## 矩阵变换特征处理

- 1252 元素数值变换

- 832 元素位置交换

- 766 元素是否关于斜角对称判断，观察下标关系来比较

- 566 矩阵进行形状变换，计算出元素总数后，只需要通过列数来计算前后矩阵的行列

- 1260 矩阵元素循环移动，观察元素下标特征进行变换 类似 566 的思路

## 字符串字母统计

- 1002 公共字母统计，分别统计每个单词的字母出现次数，与公共字母出现次数比较 这里只需要用字母来作为数组下标

## 元素变换相关

### 针对一个元素进行数值处理，之后再求和，需要保留每次处理完的数组。这里思路直接先求和，然后再进行元素处理后再求和

- 985

### 计算子数组的和 需要得到特定的和 这里统计出现的次数

- 1013

### 求和，然后判断使得两边可以相等的位置，这里不要直接暴力来处理，主要是边界情况的处理很麻烦

- 所以，直接让一边求总和，然后遍历元素后，已经求和的一边减去当前元素值，未求和的加上当前元素值，相等时得到结果

### 求总体的和，然后对特定元素进行加减处理

- 643 TODO:

### 递归移动，通过翻转数组来处理

- 189

### 寻找数组组成的的闭环开始位置

- 142 TODO:

### 变换元素使得数组元素满足升序条件

- 926 TODO: DP prefix

## 数组特定元素统计

### 统计特定元素的出现次数，然后将后面的元素都向前移动，最后在结尾补齐

- 283 26  

### 只需要统计最大的元素，出现元素则将计数 +1，变成 0 则需要重新统计

- 169

### 找出不存在的元素，将出现的元素取相反数，同时需要注意下标的对应关系以及取相反数后的判断。最后，统计所有非负数

- 448 1h

- 442 类似

### 找出一个缺失的元素，直接求和计算两个和的差值。因为只需要找一个，所以直接联想到求和

- 268

### 元素之间数值需要满足的关系 将元素的数值计数然后处理

- 954 要求 A[2i+1] = 2A[i]

- 1296 要求给定数组按照划分之后，子数组满足升序且数值连续

### 序列的组成处理，元素组成数组，判断最后的元素

- 717 30 min

## 找每个元素的最大重复序列的起始和结束位置，找特征元素的遍历处理

- 830

### 最大连续升序数列长度

- 674 类似 830 的思路，每一趟遍历统计一下长度，然后更新当前最大长度

### 计算整除的元素 这里利用取余的性质，避免了计算溢出

- 1018

### 点是否同一直线问题

- 1232 斜率的计算，使用乘法比较好

### 找到两个数的和可以整除 60 结合题目 1 two sum 以及 1018

- 不要想着排序后再处理

1. 同时因为最大值问题以及余数的性质，可以将所有可能的数值都可以直接保存到同一个数组位置

    - 对每个元素，找到其对应的差值的数量，然后加到总数量上，最后，自己的对应数量递增

2. 直接全部统计好每个数值出现的次数，然后计算序对的数量，0 和 30 可以自己和自己配对的，需要单独计算

- 1010 TODO:

### 子数组重排

- 581

### DP 动态规划 以及遍历数组赋值，这里是后面的值等于前面的总和，同时加上比较

- 初始情况以及状态转移方程判断

- 746

- 1277 统计给定二维数组的正方形数量

- 1035 统计两个数组的相同数组最大不相交连线的数量 TODO:这里需要理解

- 714 TODO: 需要理解

- 62 64

### 移除特定元素，需要记录元素出现次数，比较当前元素和目标元素，如果只有一个，则只需要一个循环，相同则递增，否则赋值

- 这里，可以统计唯一的元素的数量，也可以统计重复元素的数量

- 1089 27 217 这个是判断是否存在重复元素

- 如果是多个元素，则需要判断是否排序，同时，在一趟里面将一个元素处理完

- 26

### 计算距离的处理，特殊情况需要处理好

- 849

### 统计序对的特征，相反的序对数量，这里通过将序对的数值合并成一个数值并放到 hash table 中进行统计

- 1128

### 利用数学以及观察检查是否存在序列使得元素和满足特定的值

- 840 not done

### 数组的升序以及降序条件判断

- 941

### 变相求最大公约数

- 914

### 遍历数组找空位，分别向尾部和头部补 0，然后从第二个元素开始，判断三个元素是否都是 0 来进行空位计数

- 605 TODO:

### 非递减数组判断

- 665 i - 2, i - 1, i，其中 i - 1 的元素大于 i 的元素

- 这里，可以改变的元素可以是 i 赋值给 i - 1 或者是 i - 1 赋值给 i

- 因为将上一个元素变小对结果没有影响，所以，尽量这样处理，其中，

    - 需要判断 i - 2 元素是否小于等于 i 元素

        - 如果是则可以安全地直接将 i 赋值 给 i - 1 其中，开头的两个元素直接可以这样赋值而不需要判断了

            - 这样判断的意义是，如果满足，则将 i - 1 变成 i 的元素，也不会对结果产生影响

    - 如果不满足，则只能将 i 元素的值变成 i - 元素的值

### 回溯法以及 Golang 的 slice 指针应用 这里还需要复习，不是很理解

- 注意包含重复元素的数组，大概率需要排序后，判断重复元素出现来处理

- 216 39 40

- 39 给定没有重复元素的数组以及目标和，求满足目标和的数组，元素可以重复使用

- 40 给定含有重复元素的数组以及目标和，求满足目标和的数组，元素不能重复使用

- 216 给定数组求特定数量的元素满足给定总和，每个元素只能使用一次

- 46 给定不含重复元素的数组，求该数组元素的所有排列

- 47 给定含有重复元素的数组，求该数组元素的所有排列

- 78 给定不含重复元素的数组，求他的所有子集

- 90 给定含有重复元素的数组，求他的所有子集

- 131 字符串回文划分 这里稍微需要理解一下

- 46 47 78 90

- [回溯法小结](https://leetcode.com/problems/combination-sum/discuss/16502/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning))

    - 使用递归的方法，使用结果数组以及一个中间数组保存每次递归的中间结果来处理

### 数组元素访问遍历

- 565

- 1052 sliding windows 移动求和数组元素的范围来找到最大总和

### 求元素以及坐标和关系

- 1014 这里是将思路进行一下转换，将计算公式里面的东西进行一些拆分使得拆分后部分可以遍历时部分都变化

## 辅助数组

### 数组的重新构建使用到辅助数组，同时，注意元素的添加处理，先把元素保存，如果是 0 则需要再次保存一个 0

- 1089

- 217 类似保存了已经出现的元素

- 26 类似的处理，只是这里是统计重复元素

### 计算数学公式，通过一个元素，计算所需要的另外一个元素

- 利用辅助数组对其中一个数组的元素出现进行统计

- 针对第一个数组，在第二个数组中找所需要的值，类似 two-sum 的做法

### 使用辅助数组和原数组进行计算，这里类似 dp 信息分别保存在两个数组里面

- 119

## 计算元素距离

### 顺时针以及逆时针的距离计算，直接求总距离，然后计算一个反向就得到另一个方向的距离，最后比较

- 1184

### 求两个满足和的元素的索引，使用另一个数组存储需要的数值

- 1

## 二分查找

- 35 1011 287

### [股票购买问题汇总](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems)

- 121 122 123 188 309 714

### 通用情况分析

- 通用题目，给定每天的股票价格，我们如何获得最高的收益

- 每次遍历价格，i 将会变化，同时也要注意 k 的变化 k 的变化只存在于购买的时候 这里循环和 k 的关系还需要理解，这里需要注意实际有 k 的处理，但是部分情况下 k 没有影响

    - 穷举

    ```golang
    // s = 0, 1
    for i := 0; i < n; i++ {
        for j := k; j > 0; j--{
            dp[i][k][s] = max(buy, sell, rest)
        }
    }
    ```

- prices 表示股票价格数组，k 表示最大可交易数量，允许的操作是 购买，出售，以及不操作

- T[i][k][0], T[i][k][1] 分别表示 在第 i 天的第 k 次交易中，0，1 分别表示当前是否持有股票

- 递归处理问题的基本情况

    - T[-1][k][0] = 0, T[-1][k][1] = -Infinity

    - T[i][0][0] = 0, T[i][0][1] = -Infinity

- 递归关系

    - T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])

    - T[i][k][1] = max(T[i-1][k][1], T[i-1][k-1][0] - prices[i])

- 找到最大的收益则是需要计算 T[i][k][0] 的结果

- k = 1 直接套公式 这里 k = 1 所以不用处理 k 的影响

    - T[i][1][0] = max(T[i-1][1][0], T[i-1][1][1] + prices[i])

    - T[i][1][1] = max(T[i-1][1][1], T[i-1][0][0] - prices[i]) = max(T[i-1][1][1], -prices[i])

- k = +INF，则有 T[i-1][k][1] = T[i-1][k-1][1] T[i-1][k][0] = T[i-1][k-1][0]

    - T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])

    - T[i][k][1] = max(T[i-1][k][1], T[i-1][k-1][0] - prices[i]) = max(T[i-1][k][1], T[i-1][k][0] - prices[i])

    - 上面的公式显示，k 已经不会改变了，所以这里也可以忽略 k 的影响了

- k = 2 类似 k = 1，但是每天变成了有四个变量，因为需要确认当天是第几次操作，即第一次有两个变量，第二次有两个变量 这里 k = 2 需要考虑 k 的影响，因为是 2 所以直接写出来所有情况

    - T[i][2][0] = max(T[i-1][2][0], T[i-1][2][1] + prices[i])

    - T[i][2][1] = max(T[i-1][2][1], T[i-1][1][0] - prices[i])

    - T[i][1][0] = max(T[i-1][1][0], T[i-1][1][1] + prices[i])

    - T[i][1][1] = max(T[i-1][1][1], -prices[i])

- k = 任意数 假定 prices 的长度是 n 如果 k >= n / 2 这种情况和 k = +INF 相同，另一种情况则是每次循环内部循环 k 次

- k = +INF 同时有冷却时间 类似 k = +INF 但是考虑冷却，i - 1 出售就不能在 i 购买

    - T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])

    - T[i][k][1] = max(T[i-1][k][1], T[i-2][k][0] - prices[i])

- k = +INF 同时有交易费用 类似情况 2 但是需要在购买的时候或者销售的时候从 profit 中减去 fee

## 双指针

- 11 元素组成面积最大问题 两边向中间遍历
