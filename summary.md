# summary

## 个人小结

从 [274](https://leetcode.com/problems/h-index/) 想到，这里使用计数排序的思想，其中计数排序的思想让我想起映射这种关系
计数排序因为不是通过比较来排序，所以不受 O(nlogn) 的时间复杂度下届的影响。其中，辅助的计数数组将元素的排序映射为元素的出现次数。
辅助计数数组的第二次变化将元素的排序映射成元素在结果数组中的最后的位置，最终，结果数组将位置关系映射成最终的排序后数组
之前看到[函数编程的映射思想](https://www.zhihu.com/question/28292740)，感觉有点类似？

## 总结

变量声明时初始化节省时间

变量进行类型转换需要消耗时间

需要写代码以及测试用例

毫无思路的时候，是否是因为没有办法将问题进行很好的抽象以及建模

- 如何将问题转换为程序描述语言，然后进行编码

## 例子1

### 通过刷题，拿了很多公司（IBM, Google, Amazon, Microsoft, Zenefits, Splunk）的面试以及offer。这428题不是简单的刷一遍就过去的，而是反复练习，直到代码最优，解法最优（有时候甚至觉得自己的代码精简到一个符号都无法减少的地步）。所以有时候面试官问问题，问题还没说完，我就知道应该如何表述自己的心路历程，然后慢慢地给出最优解

### 而这一切的关键就在于：做笔记

### 对于遇到的每个题目，事后我都做上标记

普通题目，难题、好题。

需要看discuss

此外，每个题目都分为以下几个步骤做好详细的笔记：

1. 原题目
2. 自己的第一遍解法
3. 网上好的解法
4. 自己可以改进的地方
5. 进一步精简优化自己的代码直至代码简无可简（这是非常关键的一步，到达这一步，才会发现获得能力的提升远远要超过简单地把题目解出来）
6. 获得的思考（或者学习到的地方，可以是算法、数据结构或者Java的特性—例如Stream等等）每一个题目都经过至少一遍这样的迭代。这样几遍下来，我对于每个题目都有了更加深刻的理解，大部分的题目我都有自信能够写出最优解甚至代码都是最优化的（至少比论坛回复里面的最高票答案还要精简）

### 另外补充一个小trick，其实题目的数据范围是个很有用的hint

n>100k: 要求 O(nlogn) 到 O(n)，通常就是二分，heap，线段树，贪心，dp+优化，记忆化search

n>10k：和上面差不多，偶尔见到O(n sqrt(n))，或bfs之类

n>1k：基本就是O(n^2)，dp之类的也很常见

n>100：常见非常暴力O(n^3)，且很容易出难题，得想办法优化才能O(n^3)或dfs

n >10：通常是状态dp O(2^n)，或者O(n^4)的暴力题

最后还有不给范围的，通常O(n)到O(nlogn)比较靠谱

### [一些方法](https://www.zhihu.com/question/31092580/answer/439473636)

easy 以及 medium 题目，耐心以及信心就可以处理

#### 尽量找到合适的方法

比如不会的题目，可以直接看答案，然后理解答题者的思路，自己想，用例子检验为什么他的方法可以，以及代码的精髓在哪里。需要自己尽可能地参与思考

然后自己写，按照思路写成自己的代码

重复1，2来处理

不断实战，weekly contest

最后达到不看任何提示，向别人讲清楚题目

#### 毅力更加重要
