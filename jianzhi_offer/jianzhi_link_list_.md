# 剑指 offer 链表

## 3 从尾到头打印链表

- 直接递归调用，如果 nil 直接打印当前元素，非 nil 则递归调用下一个元素

## 14 链表中倒数第k个结点

```text
输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，
本题从1开始计数，即链表的尾节点是倒数第1个节点。
例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。
这个链表的倒数第3个节点是值为4的节点。
```

- 第几个可以转换为两个的相距问题

- 使用两个指针，一个先向后遍历 k 个，然后两个指针一起向后遍历到尾部， 返回前面的那个就是结果

    - 先跑的需要注意判断链表长度不足时返回 nil

## 15 反转链表

- 直接用两个指针，pre 和 cur，pre, cur := nil, head

```go
package test
type ListNode struct {
	Val  int
	Next *ListNode
}
func solution(head *ListNode) {
    pre, cur := nil, head
    for cur != nil {
        temp := cur.Next
        cur.Next = pre
        pre = cur
        cur = temp
    }
    return pre
}
```

## 16 合并两个排序的链表

- 使用三个指针，一个是合并后链表开头以及两个已排序链表的开头，类似合并已排序数组那样，后者可以更优化，直接从尾部向前遍历

- 循环条件是两个已排序链表都没有到达尾部

    - 比较两个链表当前元素的大小，将较小的添加到合并链表开头的后面

- 其中一个链表已经遍历完了，直接将另外一个链表连接到合并后的当前节点头部  

## 25 复杂链表的复制

```text
请实现 copyRandomList 函数，复制一个复杂链表。
在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。
```

- 这里麻烦的是随机指针 从原链表一直向后面遍历，下一个节点或者随机节点需要判断是否已经存在，

    - 不存在则需要创建并保存起来，然后指向
    
    - 存在则直接指向它
    
 - 复制成 AA'BB'CC' 然后再分开，创建 A'，A 指向 A' 然后 A' 指向 B
 
    - 先创建 AA'BB'CC' 这里先创建新的节点并将 next 设置好指向后再处理 random 指针
    
        - random 指针处理，遍历的还是 A，需要判断 A.Random != nil 
    
    - 再将它们分离 这个很简单就分离
 
 ## 26 二叉搜索树与双向链表
 
 ```text
输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。
```

- 对于二叉搜索树，直接中序遍历就是节点从小到大遍历

## 36 两个链表的第一个公共节点  

```text
    输入两个链表，找出它们的第一个公共节点。 a + c, b + c 
```

### 1

- 两个指针指向开头，然后一直向后遍历，如果到达尾部就指回开头

- 循环终止条件是两个节点相等，然后遍历判断见上文

### 2 

- 也可以先两个都遍历完，然后长的先遍历长度差，之后两个链表都开始遍历就会相遇

## 55 链表中环的入口结点

- 只有一个链表而已，使用两个指针都指向链表头部，然后一个每次移动一步，一个每次移动两步，两个节点将会相遇

    - 注意这里还要判断是否存在环

- 然后一个节点从相遇点出发，一个从开头出发，两个指针每次都向前一个节点，重新相遇的节点就是入口节点

## 56 删除链表中重复的结点

```text
在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 
例如，链表1->2->3->3->4->4->5 处理后为 1->2->5
```

- 注意这里将相同的值节点删除

- 增加一个指向头指针 phead 的指针 head, pre, last := head, head.Next

- 判断 last.Val == last.Next.Val 一直到最后一个相同的节点，然后 pre.Next 以及 last 等于 last.Next

- 开头节点前添加一个节点

- 初始化 pre, last 两个节点分别指向添加的头以及原来的头，这里逐个判断的是 last

- 循环终止条件是 last == nil

    - 判断 last.Next != nil 以及 last.Val == last.Next.Val 同时，一直过滤
    
        - pre.Next = last.Next last = last.Next
        
    - 不满足上述判断
    
        - pre = pre.Next last = last.Next
