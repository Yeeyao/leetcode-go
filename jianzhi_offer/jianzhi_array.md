# 剑指 offer 数组

## 1 二维数组查找

```text
在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，
每一列都按照从上到下递增的顺序排序。
请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

input: matrix [][]int, target int return: bool
```

- 这里要找目标元素，然后可以知道每一层的下界 开头，上界 结尾

    - 如果仅判断下界 则要找到第一个大于目标元素的下界，然后找它的上一行

        - 如果找到的下界在

        - 遍历完一行找不到直接返回 false

    - 如果仅判断上界 则要找到第一个大于目标元素的上界，往回找
   
 - 上述过程对于较大的数组效率很低
 
 ### 改进思路
 
 - 直接获得行列数量，然后遍历
 
     - 如果当前元素等于目标值，返回 true
     
     - 小于目标值，则将行数递增，大于目标值，将列数递减
     
        - 这里因为是按照顺序的元素，所以是行数一直递增到当前元素大于目标值，然后直接列数递减判断
 
 - 遍历完了就直接返回 false
 
 ## 5 使用两个栈实现队列
 
 - 队列是 FIFO 栈是 FILO，同一时间，只有一个栈是空的，一个是非空的
 
- 需要一个标志记录上次操作是出队还是入队列
 
 - 1 2 3 4 5
 
    - 1 2 3   2 3   2 3 4
 
 - 使用 A B 两个栈
 
 ### 操作
 
 - 没有第一次操作
 
    - 本次入队列，随便找一个空栈存放元素
    
    - 本次出队列，报错了
 
 - 上次操作是出队列
 
    - 本次是入队列，需要将元素从非空栈 A pop 到空栈 B 然后将入队列的元素 push 到 B
    
    - 本次是出队列，直接从非空栈中 pop 元素
    
- 上次操作是入队列

    - 本次是入队列，直接将元素保存到非空的栈中
    
    - 本次是出队列，将元素从非空栈 A pop 到 空栈 B 然后将 B 的栈顶元素 pop 掉
    
 ## 6 旋转数组最小数字
 
 ```text
     TODO:
    把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
    输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。
    例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  
```

```text
    i < j 作为循环判断条件
    mid = (i + j) // 2 因此可以知道 i <= m < j 这里判断 m 二分点在哪个部分
	nums[m] > nums[j] 就表示 m 在左边的子数组(m < j)，所求的元素在 m+1,j 之间，因此 i = m + 1
	nums[m] < nums[j] 则 m 在右边的子数组(因为出现在左边之前循环就应该终止了)，所求元素在 i,m 之间，执行 j = m
	nums[m] == nums[j] 无法判断，执行 j = j - 1 来缩小范围 这里有证明
    i = j 跳出循环，返回 nums[i]
```

```go
package test
func solution(nums[]int)int{
	numsLen := len(nums)
	i, j := 0, numsLen-1
	for i < j {
		// 计算中间索引
		m := i + (j-i)/2
		if nums[m] > nums[j] {
			i = m + 1
		} else if nums[m] < nums[j] {
			j = m
			// 这里处理相等的情况
		} else {
			j = j - 1
		}
	}
	return nums[i]
}
```

## 13 调整数组顺序使奇位于偶数前面

```text
    输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。
```

- 直接使用一个辅助数组，遍历原数组两次，第一次将原数组的奇数元素保存到辅助数组，第二次将偶数元素保存到辅助数组

- 或者直接使用双指针对原数组进行处理，开始 i, j := 0, len(nums) - 1 停止条件是 i >= j，

## 19 顺时针打印矩阵

- 同 leetcode 54

```text
输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。
```

- 先是第一行，然后最后一列，然后判断 left < right && top < bottom 第一列，第二行

- 使用 4 个变量，left, right, top, bottom 默认分别是 列数，行数最大最小值

## 20 包含 min 函数的栈

- 1.使用两个栈，一个保存当前元素，一个保存当前元素为止的最小值，

    - 入栈需要判断当前值是否小于最小值来更新
    
    - 出栈需要比较当前值和最小值，如果相等则两个栈都需要 pop

- 2.使用一个栈，保存的是元组{当前元素值以及当前的最小值}，入栈时需要比较当前元素和栈顶的最小值的大小来更新

## 21 栈的压入、弹出序列

```text
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。
假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，
但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。
```

- 需要注意这里压入和弹出是不确定的 使用一个辅助栈来模拟入栈，出栈操作 入栈操作按照压栈序列顺序执行压入辅助栈

- 遍历压入栈的元素

    - 先建立辅助栈，然后将入栈的元素保存到辅助栈，每次都判断辅助栈与当前的弹出栈元素是否相同，相同就一直从两个栈中弹出元素
        
    - 最后如果辅助栈为空，即索引为 0 表示全部都可以弹出

## 29 最小的k个数 

```text
输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。
```

- 使用类似归并排序或者说快排

- 将数组，左右索引以及 k 作为参数，对原数组进行划分，然后选取前面部分返回

    - 终止条件是 l > r 或者 满足数量了
    
    - 每次需要从随机划分中获取划分数量然后递归处理
    
- 随机选择处理

    - 当左右相交返回
    
    - 调用随机划分获得划分的位置索引， 计算划分数量，如果大于 k 就从左边划分 k 个，如果小于 k 就从右边划分 这里调用自身
    
    - 计算划分数量时调用快排的划分
    
## 30 连续子数组的最大和

```text
输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。
要求时间复杂度为O(n)。
```

- 一开始将累计的最大和设置为最小整数，然后临时的和设置为 0

- 遍历每个元素，加上当前元素后直接比较

- 累计和如果小于 0 需要将其置 0，因为不能影响后面的累加和

## 32 把数组排成最小的数

```text
    输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。
```

- 这里也是排序，判断是 n1n2 < n2n1 则 n1 < n2

## 35  数组中的逆序对

```text
    在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。
```
- 调用 mergeSort 参数是 nums, 0, len(nums)-1

- 如果 start >= end 表示只有一个元素，直接返回 0 逆序对

- 计算 mid，然后 cnt 是递归调用mergeSort, 参数分别是 start, mid 以及 mid +1, end

- 递归后，初始化 temp 保存本次归并结果 初始化 i, j 分别是 start, mid + 1

- 循环判断 i, j 都没有越界

	- 如果 nums[i] <= nums[j] 将元素保存到 temp 然后计数 cnt += j - (mid + 1)
	
	- 否则，只是将元素保存到 temp
	
- 分别处理左右两边没有遍历完的数据 这里都要将元素加入 temp 其中左边没有遍历完，需要 cnt += end - (mid + 1) + 1

- 最后，将 temp 的元素保存到 nums

## 37 在排序数组中查找数字出现的次数

- 同 leetcode 34

```text
统计一个数字在排序数组中出现的次数。
```

- 这里需要分别计算左右边界 

## 50 数组中的重复数字

```text
在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。
数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
```

- 直接用 map[int]int 来保存，之后遍历找出出现次数大于 1

## 51 构建乘积数组

```text
给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。
输入: [1,2,3,4,5]
输出: [120,60,40,30,24]
1 1 2 6 24
120 60 20 5 1
```

- 构建左右两个乘积数组，左边数组当前数值是当前元素之前的元素乘积，右边数组数值则是尾部到当前位置之前的乘积

- 左右两个数组的开始元素都是 1

## 64 滑动窗口最大值

```text
给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。
```

- 使用单调队列，将 nums 元素入队列，当队列数量小于 k，就元素直接加入，

- 等于 k，每遍历一个元素就需要保存队首，然后队首元素出队

- 先判断当前元素的保存位置，找到后先去掉小于当前元素的队列元素，然后将当前元素存放，判断是否需要处理最大元素

## 65 矩阵中的路径

```text
请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。
路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。
如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。
例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。
```

- 回溯法，遍历每个矩阵元素作为开始元素进行递归调用，然后每个已经访问的元素需要修改来标记为已经访问

- 同时，需要注意边界以及 4 个方向处理

- 遍历 board 的每个元素，将其 i, j 坐标数以及匹配数量作为参数然后判断返回值

	-内部先判断匹配数量
	
	- 再判断左边以及是否等于字符
	
	- 接着递归调用注意将已经访问的需要标记
