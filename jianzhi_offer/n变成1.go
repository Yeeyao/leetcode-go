package jianzhi_offer

/*
- 实现一个函数，对一个正整数 n，算得到 1 需要的最少操作次数。

    - 最少操作次数则除的次数越多越少操作次数

- 操作规则为：如果 n 为偶数，将其除以 2；如果 n 为奇数，可以加 1 或减 1；一直处理下去

将n转换到二进制空间来看（比如7为111，6为110）：
- 如果最后一位是0，则对应于偶数，直接进行除2操作。
- 如果最后一位是1，情况则有些复杂。
**如果最后几位是???01，则有可能为???001，???1111101。在第一种情况下，显然应该-1；
在第二种情况下-1和+1最终需要的步数相同。所以在???01的情况下，应该选择-1操作。
**如果最后几位是???011，则有可能为???0011，???11111011。在第一种情况下，+1和-1最终需要的步数相同；
在第二种情况下+1步数更少些。所以在???011的情况下，应该选择+1操作。
**如果最后有更多的连续1，也应该选择+1操作。

- 除以 2 的操作一般思考将数字转换为二进制 使用递归

    - 如果数字是 1 返回 0

    - 如果数字末尾为 0 除以 2

    - 分别调用 f(n+1), f(n-1) 返回较小值 + 1

*/
func solution(n int) int {
	if n == 1 {
		return 0
	}
	if n%2 == 0 {
		return 1 + solution(n/2)
	}
	x, y := solution(n-1), solution(n+1)
	if x > y {
		return y + 1
	} else {
		return x + 1
	}
}
