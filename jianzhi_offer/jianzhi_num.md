# 剑指 offer num

## 7 斐波那契数列

- 输入第 n 个数，返回对应的数值

- 0, 1, 1, 2, 3

```go
package test
func solution(n int) {
    a, b := 0, 1
    for i := 0; i < n; i++{
        a, b = b, a + b
    }
return a
}
```

## 8 青蛙跳台阶

```text
	最后一步的时候，跳上一级或者二级台阶，一级时，有 f(n - 1) 种，二级时，有 f(n - 2) 种。
	直接 DP 了，对于第 n 级，设 f(n) 为到第 n 级的不同跳法，则
	f(n) = f(n - 1) + f(n - 2) f(1) = 1 f(2) = 2
```

- 上述分析将问题转换为类似斐波那契数列，只是初始值变了 f(0) = 1, f(1) = 1 循环 从 0 到 n  

- 变种，不能连续跳 2 级，类似下面的回溯法处理，只是需要一个上次是否跳 2 级的标志

    - 如果上次跳了 2 级，再调用就只能跳 1 级，然后标志变成没有
    
    - 如果上次跳了 1 级，再调用可以跳 1 级或者 2 级

## 9 变态跳台阶

```text
     一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
```

- 直接变成了回溯法 

    - 终止条件是 
    
        - 总级数等于 n 需要累加到总的次数上面
        
        - 总级数大于 n 则直接返回了
        
    - 每次跳都是 1...n 个，
   
 ## 10 矩形覆盖
 
```text
    我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 
```
- f(1) = 1, f(2) = 2, f(3) = f(1) + f(2)

- 类似青蛙跳台阶

## 11 二进制中 1 的个数

```text
    请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。
    例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。
    输入是 num
```

### 1 逐位判断

- 循环判断条件是 num > 0，每次都累加 num & 1 然后 num 右移一位 num >>= 1

### 2 n & (n-1)

- n - 1 时，原数的最右边的 1 将变成 0，该位的右边的 0 将变成 1

- n & (n - 1) n 二进制最右边的 1 变成 0，其余不变 

- 循环判断条件是 num != 0 每次累加，然后 num = num & (num - 1)

## 12 数值的整数次方

```text
    实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。
```

- 输入是 base, exp 输出 res 如果 exp < 0，将 exp 变成正数，同时 base = 1 / base

- 循环条件是 exp > 0  每次判断 exp 的二进制当前位是否是 1，如果是将 res *= base, base *= base exp >>= 1

```go
package test
func solution(base float64, exponent int) float64{
	if base == 0 {
		return 0.0
	}
	res := 1.0
	if exponent < 0 {
		base, exponent = 1/base, -exponent
	}
	for exponent > 0 {
		if exponent & 1 > 0 {
			res *= base
		}
		base *= base
		exponent >>= 1
	}
	return res
}
```

## 28 数组中出现次数超过一半的数字

```text
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。
你可以假设数组是非空的，并且给定的数组总是存在多数元素。
```

- 直接用两个变量，数字和出现次数来判断。开始是第一个元素以及 1

- 从第二个元素遍历每个元素判断

    - 如果当前元素等于数字，将次数 + 1
    
    - 如果不等于，次数 - 1
    
        - 如果次数变成 0，数字等于当前元素，次数变成 1

## 31 1-n 整数中数字 1 出现的次数

```text
输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。
例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。
```

- 初始化 低位，高位，当前位，位因子 low, high, cur, digit

- cur == 0 加上 high * digit cur == 1 加上 high * digit + low + 1 其他 加上 (high + 1) * digit

- 注意 cur = high % 10 不断向右, high = high / 10 不断向右 low += cur * digit 注意这里 digit 一直十倍增长

## 33 丑数

```text
我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。
```

- 其实这里用动态规划，有三个因子，dp[i] = dp[i-1] 其中 dp[i-1] 是三个因子的最小值 

- 然后，三个因子的其中一个的乘积被使用后，就需要将因子递增

### 求从小到大的第 n 个丑数

- dp 初始化 dp[0] = 1, a, b, c 三个因子 0 

- 循环从 1 到 n

- n1, n2, n3 := dp[a] * 2, dp[b] * 3, dp[c] * 5

- 然后 dp[i] 是上面三个的最小值

- 然后判断 dp[i] 是否等于上述三个数，每个相等就将因子 + 1

## 40 数组中数字出现的次数

```text
    一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。
    请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。
```

- 将所有的数都做位异或，得到的结果就是 a ^ b

- 计算得到结果的一个位是 1 的数 c 这个数就是 a 和 b 其中一个数是 1 的位置

- 然后重新遍历数组元素，将和 c 做位与结果的数分开和 n1, n2 做异或

- 遍历完 n1, n2 就是结果的两个数
    
## 41 和为s的连续正数序列  

```text
输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。
序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。
```

- 这里回溯法，每个都作为开始，然后需要连续加。停止条件是等于和或者超过和

## 42 和为s的两个数字

```text
    输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。
```

- 直接使用双指针，从两边向中间移动，如果当前的和小于目标，左边指针向右移动，相等就返回指针的两个元素，大于，右边指针向左边移动

    - 因为数组是排序的
    
- 另一种方法是遍历元素，将每个元素的差值保存到 map[int]bool 中，然后第一个在 map 中存在的元素就直接返回它和它的差值

## 45 扑克牌的顺子

```text
    从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。
    2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。
```

- 初始化一个记录每个出现数字的map，遍历输入的数字 

    - 如果是 0 跳过处理
    
    - 非 0，更新最大最小值，出现过或者差值大于 5 则返回 false，否则记录下出现过

- 统计 5 张牌的最大最小值，出现重复牌或者差值大于 5 直接返回

## 46 圆圈中最后剩下的数字  

```text
0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。
例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。
```

- 套用数学公式...

## 47 求 1+2+...+n

```text
求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
```

- 使用递归，定义一个新的递归函数，判断当前数值大于 0 然后递归调用 n-1

## 48 不用加减乘除做加法

```text
写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。
```

- 位运算 处理进位和加法结果 进位用位与运算，加法做异或运算 进位为 0 停止

## 63 数据流中的中位数

```text
    如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。
    如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。
```

- 使用一个大顶堆，小顶堆，其中小顶堆保存较大的部分，大顶堆保存较小的部分

    - 其中如果总数量是奇数，则大顶堆保存多一个元素。同时结果就是大顶堆的堆顶。偶数则是两个堆顶的平均值
    
    - 需要注意元素入堆可能的堆间元素移动
    
## 66 机器人的运动范围

```text
地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，
它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。
例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。
但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？
```
    
## 67 剪绳子

```text
给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。
请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？
例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
```

- 数学验证每段为 3 的段数最多则乘积最大

- 判断 n % 3 的余数，如果是 0，则结果是 3^(n/3), 如果是 1，则结果是 3^(n/3 - 1) * 4，如果是 2，3^(n/3) * 2

