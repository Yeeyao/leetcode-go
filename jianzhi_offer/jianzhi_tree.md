# 剑指 offer 二叉树

- 直接递归，或者使用递归的返回结果判断

- 通过遍历当前节点和同一个函数递归来遍历树的所有节点

    - 17 树的子结构

## 4 重建二叉树 

- 同 LeetCode 105

```text
输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。没有重复元素。
假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：
    3
   / \
  9  20
    /  \
   15   7
```

### 分析

- 前序遍历 根，左子树，右子树的顺序；中序遍历 是左子树，根，右子树的顺序

- 前序遍历第一个节点是根节点，只要找到根节点在中序遍历的位置，

    - 在根节点前遍历的是左子树的节点，在根节点后遍历的是右子树的节点。由此可知左右子树有多少节点
    
- 由于树中节点的数量和遍历方式无关，通过中序遍历得到左右子树节点数量之后，

    - 可以根据节点数量得到前序遍历的左右子树分界，因此可以进一步得到左右子树各自的前序和中序遍历，可以使用递归方式，
    
    - 重建左右子树最后整个二叉树
    
### 递归 这里如何将思路转换为代码是关键

- 因为这里的元素都是唯一的，所有可以通过保存 map 来根据元素数值获得索引信息

-使用一个 map 存储中序遍历每个元素以及其下标。调用递归方法，对于前序遍历和中序遍历，下标从 0 到 n - 1

- 递归方法：判断前序遍历下标范围

    -若开始大于结束，则当前二叉树没有节点，返回 null。
    
    - 若开始等于结束，当前二叉树只有一个根节点
    
    -若开始小于结束，二叉树有多个节点，在中序遍历中得到根节点索引，从而得到左右子树各自下标范围和数量，知道数量后，
    
        -前序遍历中可以得到左右子树各自下标范围，然后递归重建左右子树，将当前根节点作为左右子树根节点

```go
package test
type TreeNode struct {
    Val int
    Left, Right TreeNode
}
```

## 17 树的子结构

```text
输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)
B是A的子结构， 即 A中有出现和B相同的结构和节点值。
```
- B 是 A 的子结构，则子结构的根节点可以是 A 的任意节点 先序遍历 A 的每个节点 nA 判断 A 中以 nA 为根节点的子树是否包含树 B

- 只要有一个 A 的节点是 B 则返回 true

## 18 二叉树镜像

```text
请完成一个函数，输入一个二叉树，该函数输出它的镜像。
```

- 递归判断，如果当前节点是 nil 就直接返回 nil，否则，当前节点的左子树等于递归调用当前节点的右子树结果，右子树则相反，最后返回 root

- 当题目要求返回 root 时类似这种处理，需要其他变量保存当前节点的递归调用结果，最后返回当前节点

## 22 从上到下打印二叉树

```text
从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。
```

- 使用一个辅助队列，一开始将根保存到队列，然后循环判断队列是否为空，非空，保存当前队首元素值然后将该元素的左右子树的根入队列

## 23 二叉搜索树的后序遍历序列

```text
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。
如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。
```

- 后序遍历是 左子树，右子树，根的顺序。同时二叉搜索树的性质

- 需要用开始和结束坐标作为结束条件

    - 一开始的数组结尾是第一个根，然后根向前判断
    
        - 只要大于根的就是根的右子树的元素
    
        - 只要小于根的就是根的左子树的元素
        
        - 上面从根开始找到第一个小于根的元素，后面的元素都要小于根，否则就返回 false 了
        
        - 最后递归调用

## 24 二叉树中和为某一值的路径

```text
输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。
```

- 使用回溯法，注意是从根节点到叶子节点的路径，所以后面的终止条件是和为 0 然后当前节点是叶子节点 可以剪枝

## 38 二叉树的深度

- 同 leetcode 104

```text
    输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。
```

- 直接上递归，节点是 nil 就返回 1，否则，返回当前节点左右子树递归调用的较大值

- 使用 BFS，类似树的层次遍历，每次有元素就将计数器 + 1

## 39 平衡二叉树

```text
    输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。
```

- 递归处理，先计算当前左右子树高度差，然后递归调用左右子树

## 57 二叉树的下一个节点

```text
给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。
注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。
```

- 根据中序遍历的顺序，如果有右子树，下一个节点就是右子树的最左节点，如果没有，则是父节点的左子树的根

## 58 对称二叉树

```text
请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
```

## 59 按之字形顺序打印二叉树

```text
请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，
其他行以此类推。
```

- 类似层次遍历，只是需要一个标记记录方向，然后根据记录方向，向 slice 从前到后或者从后到前存放元素

## 60 把二叉树打印成多行

```text
从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。
```

- 比上面还要简单，直接就每一层遍历完保存

## 61 序列化二叉树

```text
请实现两个函数，分别用来序列化和反序列化二叉树。
```

## 62 二叉搜索树的第k大节点

```text
给定一棵二叉搜索树，请找出其中第k大的节点。
```

- 注意这个是二叉搜索树，所以节点的大小关系确定，直接中序遍历满足大小递增关系

- 这里用中序遍历的倒序就直接求第 k 个节点就是所求

- 第 k 大就是倒数第 n - k 大的元素，n 是树的节点数量

    - 可以一个节点先遍历 k 步，然后另一个节点从根开始遍历，两个节点同时遍历，前面的停止后，返回第一个节点